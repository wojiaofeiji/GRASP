# GRASP
principle of software design

## 原因
关于设计模式的六大设计原则的资料网上很多，但是很多地方解释地都太过于笼统化，查看很多资料后， 所以整理了六大原则（带图）。

## 设计模式
要学习设计模式，有些基础知识是我们必须要先知道的，设计模式是关于类和对象的一种高效、灵活的使用方式，也就是说，必须先有类和对象，才能有设计模式的用武之地，否则一切都是空谈，那么类和对象是从那冒出来的呢？这时就需要比23种设计模式更重要更经典的GRASP模式登场了。

## GRASP
GRASP，全称为General Responsibility Assignment Software Pattern，即通用职责分配软件模式，它由《UML和模式应用》(Applying UML and Patterns)一书作者Craig Larman提出。与其将它们称之为设计模式，不如称之为设计原则，因为它是站在面向对象设计的角度，告诉我们怎样设计问题空间中的类与分配它们的行为职责，以及明确类之间的相互关系等，而不像GoF模式一样是针对特定问题而提出的解决方案.


### 1. 单一职责原则
&nbsp;&nbsp; 单一职责原则是最简单的面向对象设计原则， 他用于控制类的粒度大小， 单一原则的定义如下  
	**单一职责原则（Single Responsibility principle, SRP）: 一个类只负责一个功能领域中的职责，或可以定义为，就一个类而言，应该只有一个引起它变化的原因。**  
	
单一职责原则告诉我们：“一个类不能太累”！ 在软件系统中，一个类（大到模块，小到方法）承担的职责越多，它被复用的可能性就越低，而且一个类承担的职责过多，就相当于将这些职责耦合在一起， 当其中一个职责变化是，可能会影响其他职责的运行，因此要将这些职责进行分离，讲不同的职责封装在不同的类中，即将不同的变化原因封装到不同的类中，如果多个职责总是同时发生改变则可将它们封装在同一类中。  

**单一职责原则是实现高内聚、低耦合的指导方针，它是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，而发现类的多重职责需要设计人员具有较强的分析设计能力和相关实践经验.</font>**  


下面通过一个示例来理解单一职责原则：  
	sunnyg软件公司开发人员李某针对其CRM（Customer Relationship Management, 客户管理管理）系统中客户统计信息模块提出下图1所示初始设计方案：  
	
![srp01](https://github.com/wojiaofeiji/GRASP/blob/master/resource/image/srp01.jpeg)  

在图一当中，CustomerDataChart类承担了太多的职责， 既包含与数据库相关的方法，又包含了图表的生成与图标的展示相关方法； 如果在其他类中需要连接数据库或者使用findCustomer方法查询客户信息，无法实现代码的重用；无论是修改图表显示方式还是修改数据库连接方式都需要对类进行修改，他不至于一个引起它变化的原因。违背了单一职责原则。因此，需要对该类进行拆分：
	(1). DBUtil:负责连接数据库， 主要管理连接的处理getConnection();
	(2). CustomerDao:负责对数据库中Customer的操作，如findCustomers();
	(3). CustomerDataChart:负责图标的生成与显示，包含creatChart() displayChart()
使用单一职责原则重构后的结构如图：  

![srp02](https://github.com/wojiaofeiji/GRASP/blob/master/resource/image/srp02.jpeg)  

	

### 2. 开闭原则  

开闭原则是面向对象设计原则，可复用设计的第一块基石； 也是最重要的面向对象设计原则。  

开闭原则有Bertrand Meyer于1988年提出， 其定义如下：  
开闭原则(Open-Closed principle, OCP):一个软件试题应当对扩展开发、对修改关闭。即软件试题应尽量在不修改原有代码的基础情况下进行扩展。  
在开闭原则的定义中，软件实体可以指一个软件模块、一个由多个类组成的局部结构、一个独立类。  
任何软件都需要面临一个重要的问题，即他们的需求会随着时间的推移而发生变化。当系统需要面对新的需求时，我们应该尽量保证系统的设计框架式稳定的。如果一个软件设计符合开闭原则，那么可以非常方便的对系统进行扩展，而也在扩展时无需修改现有的代码，是的软件系统在拥有适用性和灵活性的同时具有较好的稳定性与延续性。  
随着软件规模越来越大，软件寿命越来越长，软件维护成本会越来越高，满足开闭原则的系统也变得越来越重要。  
为了满足开闭原则，需要对系统进行抽象画设计，**抽象化设计是开闭原则的关键**， 在java、C#等编程语言中，可以为系统定义一个相对稳定的抽象层，而将不同的实现行为移至具体的实现层中完成
在面向对象编程语言中都提供了接口、抽象类等机制，可以通过它们定义系统的抽象层，再通过具体类来进行扩展。如果需要修改系统的行为，无须对抽象层进行变动。
只需要增加新的具体类来实现新的业务功能即可，实现在不修改已有代码的基础上扩展系统的功能，达到开闭原则的要求。  
Sunny软件公司开发的CRM系统可以展示各种类型的图标，如饼状图、柱状图和折线图等；为了支持多种图表的显示方式，原始设计方案如下图所示：  
![ocp01](https://github.com/wojiaofeiji/GRASP/blob/master/resource/image/ocp01.jpeg)
`......
if (type.equals("pie")) {
 PieChart chart = new PieChart();
 chart.display();
}
else if (type.equals("bar")) {
 BarChart chart = new BarChart();
 chart.display();
}
......`  
上述代码中，如果需要增加新的折线图类型时，需要新增一个折线图类LineChart,还需要修改ChartDisplay类的display()方法的源代码，增加新的逻辑判断，这违反了开闭原则。  
可以进行如下的修改：  
	1. 增加一个图标抽象类AbstractChart, 将各类具体涂白哦作为其子类；
	2. ChartDisplay类正对抽象图表类进行变成， 由客户端来决定使用那种具体图标； 重构如下  
![ocp02](https://github.com/wojiaofeiji/GRASP/blob/master/resource/image/ocp02.jpeg)  
在图二中， 我们引入了抽象的AbstractChart, 且ChartDisplay针对抽象图表类进行变成， 并通过setChart()方法由客户端来设置实例化的具体图标对象；
如需要增加折线图LineChart,只需要将LineChart也作为AbstractChart的子类，在客户端像ChartDisplay中注入一个LineChart对象即可，无需修改现有的代码。  
注意：因为xml与properties等格式的配置文件一般是纯文本文件， 可以直接通过VI编辑器或者记事本进行编辑， 且无法编译， 因此在软件开发中， 一般不把对配置文件的修改认为是源代码的修改，
如果一个系统在扩展时只涉及到修改配置文件，而原有的代码文件没有做任何修改， 该系统可认为是一个符合开闭原则的系统.

### 3. 里氏替换原则
### 4. 依赖倒置原则
### 5. 接口隔离原则
### 6. 迪米特原则











































